Eufrat Algaws
00000106760

1. // Insert the file to MediaStore
// The file will be copied to the given relative path
// Input Stream is used to read the file
// Output Stream is used to write the file
private fun insertToStore(
    fileInfo: FileInfo,
    contentUri: Uri,
    contentValues: ContentValues
) {
    executor.execute {
        val insertedUri = contentResolver.insert(contentUri, contentValues)
        insertedUri?.let {
            val inputStream =
                contentResolver.openInputStream(fileInfo.uri)
            val outputStream =
                contentResolver.openOutputStream(insertedUri)
            IOUtils.copy(inputStream, outputStream)
        }
    }
}

2. In FileInfo.kt there are 5 attributes:

data class FileInfo(
    val uri: Uri,
    val file: File,
    val name: String,
    val relativePath: String,
    val mimeType: String
)


3. The first attribute uri: Uri refers to the content URI that points to the temporary file location, generated by FileProvider from the actual File. This URI is what we pass to the camera (TakePicture() / CaptureVideo()) and later use to open an input stream to read the captured image/video.

The fourth attribute relativePath: String refers to the folder path inside external storage / MediaStore where the file should be stored, for example Environment.DIRECTORY_PICTURES for photos or Environment.DIRECTORY_MOVIES for videos. This value is written into MediaStore as RELATIVE_PATH, so the system knows in which directory (Pictures/Movies) to place the media file.

Chronological order from when a user takes a picture until the file is stored in the MediaStore:

The user taps the Photo button in MainActivity.
isCapturingVideo is set to false, and checkStoragePermission { openImageCapture() } is called.

checkStoragePermission checks WRITE_EXTERNAL_STORAGE for Android 9 and below.

If permission is not granted, it requests the permission.

If permission is granted (or the device is Android 10+ where it’s not needed), it calls the onPermissionGranted lambda, which triggers openImageCapture().

In openImageCapture(), the app calls
photoInfo = providerFileManager.generatePhotoUri(System.currentTimeMillis()).
Inside generatePhotoUri a new File is created in the app’s external Pictures directory, a Uri for that file is generated via FileHelper.getUriFromFile(file) (using FileProvider), and a FileInfo object is returned containing uri, file, name, relativePath (e.g. Environment.DIRECTORY_PICTURES), and mimeType ("image/jpeg").

Still in openImageCapture(), the app launches the camera using
takePictureLauncher.launch(photoInfo?.uri).
The system camera Activity writes the captured photo to the file pointed to by this URI.

After the user finishes taking the photo and confirms, the TakePicture contract callback is invoked:

takePictureLauncher =
    registerForActivityResult(ActivityResultContracts.TakePicture()) {
        providerFileManager.insertImageToStore(photoInfo)
    }


This calls insertImageToStore(photoInfo) in ProviderFileManager.

insertImageToStore calls insertToStore(...) with:

fileInfo (the FileInfo for the photo),

an image contentUri from MediaContentHelper.getImageContentUri(),

ContentValues generated by MediaContentHelper.generateImageContentValues(fileInfo) (which include DISPLAY_NAME, RELATIVE_PATH from fileInfo.relativePath, and MIME_TYPE).

Inside insertToStore, on a background thread the app calls
contentResolver.insert(contentUri, contentValues) to create a new row in MediaStore and get its insertedUri. Then it opens an input stream from fileInfo.uri (the original file captured by the camera) and an output stream to insertedUri, and copies the bytes using IOUtils.copy(inputStream, outputStream).

After the copy finishes, the image is fully stored in MediaStore under the specified relativePath, so it becomes visible and accessible from gallery apps and other apps that can read external media.